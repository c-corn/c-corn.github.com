<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
<link href="coqdoc.css" rel="stylesheet" type="text/css"/>
<title>CoRN.tactics.csetoid_rewrite</title>
</head>

<body>

<div id="page">

<div id="header">
</div>

<div id="main">

<div class="code">

<br/>
</div>

<div class="doc">
200904: first experimental version submitted to corn; 
things need to be improved and cleaned up!; hendriks@cs.ru.nl 
</div>
<div class="code">

<br/>

<br/>
<span class="id" type="keyword">Section</span> <span class="id" type="section"><a name="move_us">move_us</a></span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="csr_wd">csr_wd</a></span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">S</span>:CSetoid) (<span class="id" type="var">R</span>:CSetoid_relation <span class="id" type="var">S</span>) (<span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">y1</span> <span class="id" type="var">y2</span>:S),<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">R</span> <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> -&gt; (<span class="id" type="var">x1</span>[=]<span class="id" type="var">y1</span>) -&gt; (<span class="id" type="var">x2</span>[=]<span class="id" type="var">y2</span>) -&gt; <span class="id" type="var">R</span> <span class="id" type="var">y1</span> <span class="id" type="var">y2</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="Ccsr_wd">Ccsr_wd</a></span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">S</span>:CSetoid) (<span class="id" type="var">R</span>:CCSetoid_relation <span class="id" type="var">S</span>) (<span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">y1</span> <span class="id" type="var">y2</span>:S),<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="var">R</span> <span class="id" type="var">x1</span> <span class="id" type="var">x2</span> -&gt; (<span class="id" type="var">x1</span>[=]<span class="id" type="var">y1</span>) -&gt; (<span class="id" type="var">x2</span>[=]<span class="id" type="var">y2</span>) -&gt; <span class="id" type="var">R</span> <span class="id" type="var">y1</span> <span class="id" type="var">y2</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="eq_wd">eq_wd</a></span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">S</span>:CSetoid) (<span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">y1</span> <span class="id" type="var">y2</span>:S),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">x1</span>[=]<span class="id" type="var">x2</span>) -&gt; (<span class="id" type="var">x1</span>[=]<span class="id" type="var">y1</span>) -&gt; (<span class="id" type="var">x2</span>[=]<span class="id" type="var">y2</span>) -&gt; <span class="id" type="var">y1</span>[=]<span class="id" type="var">y2</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="ap_wd">ap_wd</a></span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">S</span>:CSetoid) (<span class="id" type="var">x1</span> <span class="id" type="var">x2</span> <span class="id" type="var">y1</span> <span class="id" type="var">y2</span>:S),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">x1</span>[#]<span class="id" type="var">x2</span>) -&gt; (<span class="id" type="var">x1</span>[=]<span class="id" type="var">y1</span>) -&gt; (<span class="id" type="var">x2</span>[=]<span class="id" type="var">y2</span>) -&gt; <span class="id" type="var">y1</span>[#]<span class="id" type="var">y2</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="CAnd_proj1">CAnd_proj1</a></span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span>:CProp, <span class="id" type="var">A</span> <span class="id" type="var">and</span> <span class="id" type="var">B</span> -&gt; <span class="id" type="var">A</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="CAnd_proj2">CAnd_proj2</a></span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span>:CProp, <span class="id" type="var">A</span> <span class="id" type="var">and</span> <span class="id" type="var">B</span> -&gt; <span class="id" type="var">B</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="COr_elim">COr_elim</a></span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">A</span> <span class="id" type="var">B</span> <span class="id" type="var">C</span>:CProp, (<span class="id" type="var">A</span> -&gt; <span class="id" type="var">C</span>) -&gt; (<span class="id" type="var">B</span> -&gt; <span class="id" type="var">C</span>) -&gt; <span class="id" type="var">A</span> <span class="id" type="var">or</span> <span class="id" type="var">B</span> -&gt; <span class="id" type="var">C</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="section"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#move_us">move_us</a></span>.<br/>

<br/>
</div>

<div class="doc">
Definition of <span class="inlinecode"><span class="id" type="var">csetoid_rewrite</span></span>: a rewrite tactic for setoid equality; 
it rewrites within formulae of type <span class="inlinecode"><span class="id" type="keyword">Prop</span></span> and <span class="inlinecode"><span class="id" type="var">CProp</span></span>, built up from 
connectives <span class="inlinecode">-&gt;</span>, <span class="inlinecode"><span class="id" type="var">and</span></span>, <span class="inlinecode"><span class="id" type="var">CAnd</span></span>, <span class="inlinecode"><span class="id" type="var">or</span></span>, <span class="inlinecode"><span class="id" type="var">COr</span></span>, <span class="inlinecode"><span class="id" type="var">iff</span></span>, <span class="inlinecode">&hArr;</span>, <span class="inlinecode"><span class="id" type="var">not</span></span>, <span class="inlinecode">~</span>, 
<span class="inlinecode">~</span>, and atomic formulae <span class="inlinecode">(<span class="id" type="var">P</span> <span class="id" type="var">t</span>)</span>, <span class="inlinecode">(<span class="id" type="var">R</span> <span class="id" type="var">t</span> <span class="id" type="var">s</span>)</span>, <span class="inlinecode"><span class="id" type="var">t</span>&equiv;<span class="id" type="var">s</span></span>, <span class="inlinecode"><span class="id" type="var">t</span>[#]<span class="id" type="var">s</span></span> for 
<span class="inlinecode"><span class="id" type="var">T</span>:CSetoid</span>, <span class="inlinecode"><span class="id" type="var">t</span>,s:T</span>, <span class="inlinecode"><span class="id" type="var">P</span>:(CSetoid_predicate <span class="id" type="var">T</span>)</span>, <span class="inlinecode"><span class="id" type="var">R</span>:(CSetoid_relation <span class="id" type="var">T</span>)</span>, 
<span class="inlinecode"><span class="id" type="var">R</span>:(CCSetoid_relation <span class="id" type="var">T</span>)</span>. Note that atoms are built up from predicates and 
relations that are well-defined with respect to setoid equality.

<br/><br/>
Setoid terms of type <span class="inlinecode"><span class="id" type="var">T</span></span> are terms constructed by <span class="inlinecode">(<span class="id" type="var">f</span> <span class="id" type="var">s</span>)</span>, <span class="inlinecode">(<span class="id" type="var">g</span> <span class="id" type="var">s</span> <span class="id" type="var">s'</span>)</span>, 
<span class="inlinecode">(<span class="id" type="var">h</span> <span class="id" type="var">s</span> <span class="id" type="var">s_</span>)</span>, where <span class="inlinecode"><span class="id" type="var">f</span>:(CSetoid_fun <span class="id" type="var">S</span> <span class="id" type="var">T</span>)</span>, <span class="inlinecode"><span class="id" type="var">g</span>:(CSetoid_bin_fun <span class="id" type="var">S</span> <span class="id" type="var">S'</span> <span class="id" type="var">T</span>)</span>, 
<span class="inlinecode"><span class="id" type="var">h</span>:(CSetoid_part_fun <span class="id" type="var">S</span> <span class="id" type="var">T</span>)</span>, <span class="inlinecode"><span class="id" type="var">s</span>:S</span>, <span class="inlinecode"><span class="id" type="var">s'</span>:S'</span>, <span class="inlinecode"><span class="id" type="var">s_</span>:(cspf_dom <span class="id" type="var">S</span> <span class="id" type="var">T</span> <span class="id" type="var">f</span> <span class="id" type="var">s</span>)</span>;
needless to say, those setoid functions respect setoid equality.

<br/><br/>
Tactic <span class="inlinecode"><span class="id" type="var">csetoid_rewrite</span></span> is composed of tactics <span class="inlinecode"><span class="id" type="var">total_csetoid_rewrite</span></span> and 
<span class="inlinecode"><span class="id" type="var">partial_csetoid_rewrite</span></span>. The former is applied in case there are no partial 
setoid functions present in the goal. The latter if there are. We further 
explain this separation. 

<br/><br/>
To define the rewrite tactic we use the method of reflection, see <span class="inlinecode">1</span>.
Because we have to deal with partial functions (see the definition of 
<span class="inlinecode"><span class="id" type="var">CSetoid_part_fun</span></span> in file <span class="inlinecode"><span class="id" type="var">CSetoids.v</span></span>), we use 
<em>partial</em> reflection, see <span class="inlinecode">2</span>. Partial reflection means to have an
interpretation <em>relation</em> instead of an 
interpretation function.

<br/><br/>
Unfortunately, we were unable to define our tactic for the most general case,
that is, for terms that contain both partial functions as well as setoid 
functions whose domain(s) and co-domain are not necessarily the same.
When proving lemmas involving statements <span class="inlinecode"><span class="id" type="var">e</span> <span class="id" type="var">II</span>^r <span class="id" type="var">t</span></span> (saying <span class="inlinecode"><span class="id" type="var">t</span></span> is an 
interpretation of syntactic expression <span class="inlinecode"><span class="id" type="var">e</span></span> under the variable assigment <span class="inlinecode"><span class="id" type="var">r</span></span>, 
one often needs to reason by induction over <span class="inlinecode"><span class="id" type="var">e</span></span> and then inverting the so 
obtained instances of the inductively defined <span class="inlinecode"><span class="id" type="var">e</span> <span class="id" type="var">II</span>^rho <span class="id" type="var">t</span></span>. However, in the 
general case where we have to deal with functions whose domain and co-domain 
differ, inversion doesn't yield the desired result. Consider, for instance, 
<span class="inlinecode"><span class="id" type="var">var</span> <span class="id" type="var">II</span>^r <span class="id" type="var">t</span></span>. Here, we want to perform inversion and obtain <span class="inlinecode"><span class="id" type="var">t</span>=r</span>, for
<span class="inlinecode"><span class="id" type="var">var</span> <span class="id" type="var">II</span>^r <span class="id" type="var">r</span></span> is a defining clause of <span class="inlinecode"><span class="id" type="var">II</span></span> and moreover the only one mentioning
<span class="inlinecode"><span class="id" type="var">var</span></span>. However, inversion returns somthing like <span class="inlinecode">&lt;p,t&gt; = &lt;p,r&gt;</span>. 
This has got to do with the so-called elimination predicate which predicts 
the type of the outcome of a case analysis dependent on the destructed 
variable. For more info ask the author and see his related
<a href="http://pauillac.inria.fr/pipermail/coq-club/2003/001127.html"> 
mail</a> to the coq-club.

<br/><br/>
We opted for the next best option of using two tactics, one using total 
reflection, its application being restricted to terms constructed 
from total functions (domain(s) and co-domain are allowed to be distinct).
The other using partial reflection, its application being restricted to
terms built up from (partial as well as total) 
<em>operations</em> (i.e. functions whose domain(s) and co-domain are 
equal).

<br/><br/>
References:

<br/><br/>
<span class="inlinecode">1</span> Boutin, "Using Reflection to Build Efficient and Certified Decision 
Procedures", TACS, LNCS 1281, pp. 515--529, 1997.

<br/><br/>
<span class="inlinecode">2</span> Geuvers, Wiedijk and Zwanenburg, "Equational Reasoning via Partial 
Reflection", TPHOLs, LNCS 1896, pp. 162--178, 2000.

</div>
<div class="code">

<br/>

<br/>
<span class="id" type="keyword">Section</span> <span class="id" type="section"><a name="syntactic_total_setoid_expressions">syntactic_total_setoid_expressions</a></span>.<br/>

<br/>
</div>

<div class="doc">
Syntactic setoid expressions reflecting setoid terms built from total 
setoid functions. <span class="inlinecode"><span class="id" type="var">S</span></span> is the setoid of the subterm to be replaced. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="inductive"><a name="tot_set_exp">tot_set_exp</a></span> (<span class="id" type="var">S</span>:CSetoid) : <span class="id" type="record"><a class="idref" href="CoRN.algebra.CSetoids.html#CSetoid">CSetoid</a></span> -&gt; <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="tse_var">tse_var</a></span> : <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tot_set_exp">tot_set_exp</a></span> <span class="id" type="var">S</span> <span class="id" type="var">S</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="tse_fun">tse_fun</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">T1</span> <span class="id" type="var">T2</span>:CSetoid,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="record"><a class="idref" href="CoRN.algebra.CSetoids.html#CSetoid_fun">CSetoid_fun</a></span> <span class="id" type="var">T1</span> <span class="id" type="var">T2</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tot_set_exp">tot_set_exp</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T1</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tot_set_exp">tot_set_exp</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T2</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="tse_bfun">tse_bfun</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">T1</span> <span class="id" type="var">T2</span> <span class="id" type="var">T3</span>:CSetoid,<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="record"><a class="idref" href="CoRN.algebra.CSetoids.html#CSetoid_bin_fun">CSetoid_bin_fun</a></span> <span class="id" type="var">T1</span> <span class="id" type="var">T2</span> <span class="id" type="var">T3</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tot_set_exp">tot_set_exp</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T1</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tot_set_exp">tot_set_exp</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T2</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tot_set_exp">tot_set_exp</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T3</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="tse_con">tse_con</a></span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">T</span>:CSetoid, <span class="id" type="var">T</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tot_set_exp">tot_set_exp</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T</span>.<br/>

<br/>
</div>

<div class="doc">
Interpretation of `total' setoid expressions. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="definition"><a name="tse_int">tse_int</a></span> (<span class="id" type="var">S</span> <span class="id" type="var">T</span>:CSetoid) (<span class="id" type="var">r</span>:S) (<span class="id" type="var">e</span>:tot_set_exp <span class="id" type="var">S</span> <span class="id" type="var">T</span>) {<span class="id" type="keyword">struct</span> <span class="id" type="var">e</span>} : <span class="id" type="var">T</span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tse_var">tse_var</a></span> =&gt; <span class="id" type="var">r</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tse_fun">tse_fun</a></span> <span class="id" type="var">T1</span> <span class="id" type="var">T2</span> <span class="id" type="var">f</span> <span class="id" type="var">e0</span> =&gt; <span class="id" type="var">f</span> (<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tse_int">tse_int</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T1</span> <span class="id" type="var">r</span> <span class="id" type="var">e0</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tse_bfun">tse_bfun</a></span> <span class="id" type="var">T1</span> <span class="id" type="var">T2</span> <span class="id" type="var">T3</span> <span class="id" type="var">f</span> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span> =&gt; <span class="id" type="var">f</span> (<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tse_int">tse_int</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T1</span> <span class="id" type="var">r</span> <span class="id" type="var">e1</span>) (<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tse_int">tse_int</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T2</span> <span class="id" type="var">r</span> <span class="id" type="var">e2</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tse_con">tse_con</a></span> <span class="id" type="var">T</span> <span class="id" type="var">t</span> =&gt; <span class="id" type="var">t</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">tse_int</span></span> is well-defined. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="tse_int_wd">tse_int_wd</a></span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">S</span> <span class="id" type="var">T</span>:CSetoid) (<span class="id" type="var">r1</span> <span class="id" type="var">r2</span>:S),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">r1</span>[=]<span class="id" type="var">r2</span>) -&gt; <span class="id" type="keyword">forall</span> <span class="id" type="var">e</span>:tot_set_exp <span class="id" type="var">S</span> <span class="id" type="var">T</span>, <span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tse_int">tse_int</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T</span> <span class="id" type="var">r1</span> <span class="id" type="var">e</span>[=]<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#tse_int">tse_int</a></span> <span class="id" type="var">S</span> <span class="id" type="var">T</span> <span class="id" type="var">r2</span> <span class="id" type="var">e</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="section"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#syntactic_total_setoid_expressions">syntactic_total_setoid_expressions</a></span>.<br/>

<br/>
</div>

<div class="doc">
The `quote function' maps setoid terms <span class="inlinecode"><span class="id" type="var">t</span>:T</span> to syntactic expressions 
<span class="inlinecode">(<span class="id" type="var">tot_set_exp</span> <span class="id" type="var">S</span> <span class="id" type="var">T</span>)</span>; term <span class="inlinecode"><span class="id" type="var">r</span>:S</span> (supposed to be a subterm of <span class="inlinecode"><span class="id" type="var">t</span>:T</span> to be 
replaced later on) is mapped to <span class="inlinecode">(<span class="id" type="var">tse_var</span> <span class="id" type="var">r</span>)</span>. Other `leafs' <span class="inlinecode"><span class="id" type="var">t0</span>:T'</span> of <span class="inlinecode"><span class="id" type="var">t</span></span> 
are mapped to <span class="inlinecode">(<span class="id" type="var">tse_con</span> <span class="id" type="var">S</span> <span class="id" type="var">T'</span> <span class="id" type="var">t0</span>)</span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Given <span class="inlinecode"><span class="id" type="var">S</span>:CSetoid;<span class="id" type="var">r1</span>,r2:S</span> and <span class="inlinecode"><span class="id" type="var">A</span>:Prop</span> or <span class="inlinecode"><span class="id" type="var">A</span>:CProp</span>, 
<span class="inlinecode">(<span class="id" type="var">replace_in_formula1</span> <span class="id" type="var">S</span> <span class="id" type="var">r1</span> <span class="id" type="var">r2</span> <span class="id" type="var">A</span>)</span> 
replaces all occurrences of subterm <span class="inlinecode"><span class="id" type="var">r1</span></span> in <span class="inlinecode"><span class="id" type="var">A</span></span> by <span class="inlinecode"><span class="id" type="var">r2</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Given <span class="inlinecode"><span class="id" type="var">S</span>:CSetoid;<span class="id" type="var">r1</span>,r2:S;<span class="id" type="var">h</span>:r1&equiv;<span class="id" type="var">r2</span>;<span class="id" type="var">h0</span>:r2&equiv;<span class="id" type="var">r1</span></span> and <span class="inlinecode"><span class="id" type="var">A</span>:CProp</span> or <span class="inlinecode"><span class="id" type="var">A</span>:Prop</span>,
we get <span class="inlinecode">(<span class="id" type="var">tot_set_rewr_prf1</span> <span class="id" type="var">S</span> <span class="id" type="var">r1</span> <span class="id" type="var">r2</span> <span class="id" type="var">h</span> <span class="id" type="var">h0</span> <span class="id" type="var">A</span>) : <span class="id" type="var">A</span>-&gt;A[<span class="id" type="var">r1</span>:=r2]</span> and
<span class="inlinecode">(<span class="id" type="var">tot_set_rewr_prf2</span> <span class="id" type="var">S</span> <span class="id" type="var">r1</span> <span class="id" type="var">r2</span> <span class="id" type="var">h</span> <span class="id" type="var">h0</span> <span class="id" type="var">A</span>) : <span class="id" type="var">A</span>[<span class="id" type="var">r1</span>:=r2]-&gt;A</span> where <span class="inlinecode"><span class="id" type="var">A</span>[<span class="id" type="var">r1</span>:=r2]</span> denotes 
<span class="inlinecode">(<span class="id" type="var">tot_repl_in_form</span> <span class="id" type="var">S</span> <span class="id" type="var">r1</span> <span class="id" type="var">r2</span> <span class="id" type="var">A</span>)</span>. The argument <span class="inlinecode"><span class="id" type="var">h0</span>:r2&equiv;<span class="id" type="var">r1</span></span> is present to avoid 
iterated application of <span class="inlinecode"><span class="id" type="var">eq_symmetric</span></span>.

</div>
<div class="code">

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="definition"><a name="CSetoid_part_op">CSetoid_part_op</a></span> := <span class="id" type="record"><a class="idref" href="CoRN.algebra.CSetoidFun.html#PartFunct">PartFunct</a></span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="definition"><a name="cspf_dom">cspf_dom</a></span> (<span class="id" type="var">T</span> <span class="id" type="var">_</span>:CSetoid) := <span class="id" type="projection"><a class="idref" href="CoRN.algebra.CSetoidFun.html#pfdom">pfdom</a></span> <span class="id" type="var">T</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="definition"><a name="cspf_dom_wd">cspf_dom_wd</a></span> (<span class="id" type="var">T</span> <span class="id" type="var">_</span>:CSetoid) := <span class="id" type="projection"><a class="idref" href="CoRN.algebra.CSetoidFun.html#dom_wd">dom_wd</a></span> <span class="id" type="var">T</span>.<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="definition"><a name="cspf_wd">cspf_wd</a></span> (<span class="id" type="var">T</span>:CSetoid) := <span class="id" type="lemma"><a class="idref" href="CoRN.algebra.CSetoidFun.html#pfwdef">pfwdef</a></span> <span class="id" type="var">T</span>.<br/>

<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="inductive"><a name="my_sigT">my_sigT</a></span> (<span class="id" type="var">A</span>:Type) (<span class="id" type="var">P</span>:A -&gt; <span class="id" type="keyword">Type</span>) : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="constructor"><a name="my_existT">my_existT</a></span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">x</span>:A, <span class="id" type="var">P</span> <span class="id" type="var">x</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#my_sigT">my_sigT</a></span> <span class="id" type="var">A</span> <span class="id" type="var">P</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="definition"><a name="proj1_my_sigT">proj1_my_sigT</a></span> (<span class="id" type="var">A</span>:Type) (<span class="id" type="var">P</span>:A -&gt; <span class="id" type="keyword">Type</span>) (<span class="id" type="var">e</span>:my_sigT <span class="id" type="var">A</span> <span class="id" type="var">P</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#my_existT">my_existT</a></span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> =&gt; <span class="id" type="var">a</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="definition"><a name="proj2_my_sigT">proj2_my_sigT</a></span> (<span class="id" type="var">A</span>:Type) (<span class="id" type="var">P</span>:A -&gt; <span class="id" type="keyword">Type</span>) (<span class="id" type="var">e</span>:my_sigT <span class="id" type="var">A</span> <span class="id" type="var">P</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">return</span> <span class="id" type="var">P</span> (<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#proj1_my_sigT">proj1_my_sigT</a></span> <span class="id" type="var">A</span> <span class="id" type="var">P</span> <span class="id" type="var">e</span>) <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#my_existT">my_existT</a></span> <span class="id" type="var">a</span> <span class="id" type="var">b</span> =&gt; <span class="id" type="var">b</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>

<br/>
<span class="id" type="keyword">Section</span> <span class="id" type="section"><a name="syntactic_partial_setoid_expressions">syntactic_partial_setoid_expressions</a></span>.<br/>

<br/>
<span class="id" type="keyword">Variable</span> <span class="id" type="variable"><a name="syntactic_partial_setoid_expressions.T">T</a></span> : <span class="id" type="record"><a class="idref" href="CoRN.algebra.CSetoids.html#CSetoid">CSetoid</a></span>.<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="inductive"><a name="part_set_exp">part_set_exp</a></span> : <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_var">pse_var</a></span> : <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_uop">pse_uop</a></span> : <span class="id" type="definition"><a class="idref" href="CoRN.algebra.CSetoids.html#CSetoid_un_op">CSetoid_un_op</a></span> <span class="id" type="var">T</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_bop">pse_bop</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="definition"><a class="idref" href="CoRN.algebra.CSetoids.html#CSetoid_bin_op">CSetoid_bin_op</a></span> <span class="id" type="var">T</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_pop">pse_pop</a></span> : <span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#CSetoid_part_op">CSetoid_part_op</a></span> <span class="id" type="var">T</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_con">pse_con</a></span> : <span class="id" type="var">T</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span>.<br/>

<br/>
</div>

<div class="doc">
Interpretation as a relation between syntactic expressions and 
(semantical) setoid terms; <span class="inlinecode"><span class="id" type="var">r</span></span> is the term to be replaced (later on). 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Variable</span> <span class="id" type="variable"><a name="syntactic_partial_setoid_expressions.r">r</a></span> : <span class="id" type="var">T</span>.<br/>

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="inductive"><a name="pse_int">pse_int</a></span> : <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span> -&gt; <span class="id" type="var">T</span> -&gt; <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_int_var">pse_int_var</a></span> : <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_var">pse_var</a></span> <span class="id" type="var">r</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_int_uop">pse_int_uop</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">F</span>:CSetoid_un_op <span class="id" type="var">T</span>) (<span class="id" type="var">e</span>:part_set_exp) (<span class="id" type="var">t</span>:T),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">e</span> <span class="id" type="var">t</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> (<span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_uop">pse_uop</a></span> <span class="id" type="var">F</span> <span class="id" type="var">e</span>) (<span class="id" type="var">F</span> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_int_bop">pse_int_bop</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">F</span>:CSetoid_bin_op <span class="id" type="var">T</span>) (<span class="id" type="var">e1</span> <span class="id" type="var">e2</span>:part_set_exp) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">t1</span> <span class="id" type="var">t2</span>:T),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">e1</span> <span class="id" type="var">t1</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">e2</span> <span class="id" type="var">t2</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> (<span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_bop">pse_bop</a></span> <span class="id" type="var">F</span> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span>) (<span class="id" type="var">F</span> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_int_pop">pse_int_pop</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">F</span>:CSetoid_part_op <span class="id" type="var">T</span>) (<span class="id" type="var">e</span>:part_set_exp) <br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id" type="var">t</span>:T),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">e</span> <span class="id" type="var">t</span> -&gt;<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> <span class="id" type="var">Ht</span>:cspf_dom <span class="id" type="var">T</span> <span class="id" type="var">T</span> <span class="id" type="var">F</span> <span class="id" type="var">t</span>, <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> (<span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_pop">pse_pop</a></span> <span class="id" type="var">F</span> <span class="id" type="var">e</span>) (<span class="id" type="var">F</span> <span class="id" type="var">t</span> <span class="id" type="var">Ht</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="pse_int_con">pse_int_con</a></span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">t</span>:T, <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> (<span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_con">pse_con</a></span> <span class="id" type="var">t</span>) <span class="id" type="var">t</span>.<br/>

<br/>
</div>

<div class="doc">
`Heavy' syntactic expressions, carrying their own interpretation. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Inductive</span> <span class="id" type="inductive"><a name="part_set_xexp">part_set_xexp</a></span> : <span class="id" type="var">T</span> -&gt; <span class="id" type="keyword">Type</span> :=<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="psxe_var">psxe_var</a></span> : <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_xexp">part_set_xexp</a></span> <span class="id" type="var">r</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="psxe_uop">psxe_uop</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">F</span>:CSetoid_un_op <span class="id" type="var">T</span>) (<span class="id" type="var">t</span>:T),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_xexp">part_set_xexp</a></span> <span class="id" type="var">t</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_xexp">part_set_xexp</a></span> (<span class="id" type="var">F</span> <span class="id" type="var">t</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="psxe_bop">psxe_bop</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">F</span>:CSetoid_bin_op <span class="id" type="var">T</span>) (<span class="id" type="var">t1</span> <span class="id" type="var">t2</span>:T),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_xexp">part_set_xexp</a></span> <span class="id" type="var">t1</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_xexp">part_set_xexp</a></span> <span class="id" type="var">t2</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_xexp">part_set_xexp</a></span> (<span class="id" type="var">F</span> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="psxe_pop">psxe_pop</a></span> :<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">F</span>:CSetoid_part_op <span class="id" type="var">T</span>) (<span class="id" type="var">t</span>:T) (<span class="id" type="var">Ht</span>:cspf_dom <span class="id" type="var">T</span> <span class="id" type="var">T</span> <span class="id" type="var">F</span> <span class="id" type="var">t</span>),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_xexp">part_set_xexp</a></span> <span class="id" type="var">t</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_xexp">part_set_xexp</a></span> (<span class="id" type="var">F</span> <span class="id" type="var">t</span> <span class="id" type="var">Ht</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a name="psxe_con">psxe_con</a></span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">t</span>:T, <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_xexp">part_set_xexp</a></span> <span class="id" type="var">t</span>.<br/>

<br/>
</div>

<div class="doc">
Interpretation of proof loaded (`heavy') syntactic expressions; 
extracts the semantical component from heavy expressions. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="definition"><a name="psxe_int">psxe_int</a></span> <span class="id" type="var">t</span> (<span class="id" type="var">_</span>:part_set_xexp <span class="id" type="var">t</span>) := <span class="id" type="var">t</span>.<br/>

<br/>
</div>

<div class="doc">
The forgetful mapping from heavy to light syntactic expressions;
extracts the syntactical component from heavy expressions. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Fixpoint</span> <span class="id" type="definition"><a name="forget">forget</a></span> (<span class="id" type="var">t</span>:T) (<span class="id" type="var">e</span>:part_set_xexp <span class="id" type="var">t</span>) {<span class="id" type="keyword">struct</span> <span class="id" type="var">e</span>} : <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#part_set_exp">part_set_exp</a></span> :=<br/>
&nbsp;&nbsp;<span class="id" type="keyword">match</span> <span class="id" type="var">e</span> <span class="id" type="keyword">with</span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#psxe_var">psxe_var</a></span> =&gt; <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_var">pse_var</a></span><br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#psxe_uop">psxe_uop</a></span> <span class="id" type="var">F</span> <span class="id" type="var">t0</span> <span class="id" type="var">e0</span> =&gt; <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_uop">pse_uop</a></span> <span class="id" type="var">F</span> (<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#forget">forget</a></span> <span class="id" type="var">e0</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#psxe_bop">psxe_bop</a></span> <span class="id" type="var">F</span> <span class="id" type="var">t1</span> <span class="id" type="var">t2</span> <span class="id" type="var">e1</span> <span class="id" type="var">e2</span> =&gt; <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_bop">pse_bop</a></span> <span class="id" type="var">F</span> (<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#forget">forget</a></span> <span class="id" type="var">e1</span>) (<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#forget">forget</a></span> <span class="id" type="var">e2</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#psxe_pop">psxe_pop</a></span> <span class="id" type="var">F</span> <span class="id" type="var">t0</span> <span class="id" type="var">H</span> <span class="id" type="var">e0</span> =&gt; <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_pop">pse_pop</a></span> <span class="id" type="var">F</span> (<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#forget">forget</a></span> <span class="id" type="var">e0</span>)<br/>
&nbsp;&nbsp;| <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#psxe_con">psxe_con</a></span> <span class="id" type="var">t</span> =&gt; <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_con">pse_con</a></span> <span class="id" type="var">t</span><br/>
&nbsp;&nbsp;<span class="id" type="keyword">end</span>.<br/>

<br/>
</div>

<div class="doc">
The second extraction of an heavy expression is an interpretation 
of its first extraction (note <span class="inlinecode">(<span class="id" type="var">xexp_int</span> <span class="id" type="var">t</span> <span class="id" type="var">e</span>)=t</span>). 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="extract_correct">extract_correct</a></span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">t</span>:T) (<span class="id" type="var">e</span>:part_set_xexp <span class="id" type="var">t</span>), <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> (<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#forget">forget</a></span> <span class="id" type="var">e</span>) <span class="id" type="var">t</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="pse_int_var_inv">pse_int_var_inv</a></span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">t</span>:T, <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_var">pse_var</a></span> <span class="id" type="var">t</span> -&gt; <span class="id" type="var">t</span> = <span class="id" type="var">r</span>.<br/>

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="pse_int_con_inv">pse_int_con_inv</a></span> : <span class="id" type="keyword">forall</span> <span class="id" type="var">c</span> <span class="id" type="var">t</span>:T, <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> (<span class="id" type="constructor"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_con">pse_con</a></span> <span class="id" type="var">c</span>) <span class="id" type="var">t</span> -&gt; <span class="id" type="var">t</span> = <span class="id" type="var">c</span>.<br/>

<br/>
</div>

<div class="doc">
The interpretation relation <span class="inlinecode"><span class="id" type="var">pse_int</span></span> is a partial function. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="pse_int_ext">pse_int_ext</a></span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">e</span>:part_set_exp) (<span class="id" type="var">t</span> <span class="id" type="var">t'</span>:T), <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">e</span> <span class="id" type="var">t</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">e</span> <span class="id" type="var">t'</span> -&gt; <span class="id" type="var">t</span>[=]<span class="id" type="var">t'</span>.<br/>

<br/>
<span class="id" type="keyword">End</span> <span class="id" type="section"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#syntactic_partial_setoid_expressions">syntactic_partial_setoid_expressions</a></span>.<br/>

<br/>
</div>

<div class="doc">
<span class="inlinecode"><span class="id" type="var">pse_int</span></span> is well-founded. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="pse_int_wd">pse_int_wd</a></span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">T</span>:CSetoid) (<span class="id" type="var">r</span> <span class="id" type="var">r'</span>:T),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">r</span>[=]<span class="id" type="var">r'</span>) -&gt;<br/>
&nbsp;&nbsp;&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">e</span>:part_set_exp <span class="id" type="var">T</span>) (<span class="id" type="var">t</span> <span class="id" type="var">t'</span>:T),<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">r</span> <span class="id" type="var">e</span> <span class="id" type="var">t</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">r'</span> <span class="id" type="var">e</span> <span class="id" type="var">t'</span> -&gt; <span class="id" type="var">t</span>[=]<span class="id" type="var">t'</span>.<br/>

<br/>
</div>

<div class="doc">
The following lemma states that if <span class="inlinecode"><span class="id" type="var">r1</span>&equiv;<span class="id" type="var">r2</span></span> and <span class="inlinecode"><span class="id" type="var">t1</span></span> is an interpretation 
of <span class="inlinecode"><span class="id" type="var">e</span></span> under the variable assigment <span class="inlinecode"><span class="id" type="var">r1</span></span>, then there exists an interpretation 
<span class="inlinecode"><span class="id" type="var">t2</span></span> of <span class="inlinecode"><span class="id" type="var">e</span></span> under the assignment <span class="inlinecode"><span class="id" type="var">r2</span></span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Lemma</span> <span class="id" type="lemma"><a name="replacement_lemma">replacement_lemma</a></span> :<br/>
&nbsp;<span class="id" type="keyword">forall</span> (<span class="id" type="var">T</span>:CSetoid) (<span class="id" type="var">e</span>:part_set_exp <span class="id" type="var">T</span>) (<span class="id" type="var">r1</span> <span class="id" type="var">r2</span> <span class="id" type="var">t1</span>:T),<br/>
&nbsp;&nbsp;&nbsp;(<span class="id" type="var">r1</span>[=]<span class="id" type="var">r2</span>) -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">r1</span> <span class="id" type="var">e</span> <span class="id" type="var">t1</span> -&gt; <span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#my_sigT">my_sigT</a></span> <span class="id" type="var">T</span> (<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">r2</span> <span class="id" type="var">e</span>).<br/>

<br/>
</div>

<div class="doc">
Given <span class="inlinecode"><span class="id" type="var">H</span>:r1&equiv;<span class="id" type="var">r2</span></span> and <span class="inlinecode"><span class="id" type="var">H0</span>:(pse_int <span class="id" type="var">r1</span> <span class="id" type="var">e</span> <span class="id" type="var">t1</span>)</span>, the first projection of 
<span class="inlinecode">(<span class="id" type="var">replacement_lemma</span> <span class="id" type="var">H</span> <span class="id" type="var">H0</span>)</span> is the term <span class="inlinecode"><span class="id" type="var">t2</span></span> obtained by replacing in <span class="inlinecode"><span class="id" type="var">t1</span></span> 
subterm <span class="inlinecode"><span class="id" type="var">r1</span></span> by <span class="inlinecode"><span class="id" type="var">r2</span></span>. The second projection is the proof of 
<span class="inlinecode">(<span class="id" type="var">pse_int</span> <span class="id" type="var">r2</span> <span class="id" type="var">e</span> <span class="id" type="var">t2</span>)</span>. 
</div>
<div class="code">

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="definition"><a name="replace_in_term">replace_in_term</a></span> (<span class="id" type="var">T</span>:CSetoid) (<span class="id" type="var">r1</span> <span class="id" type="var">r2</span> <span class="id" type="var">t1</span>:T) <br/>
&nbsp;&nbsp;(<span class="id" type="var">e</span>:part_set_exp <span class="id" type="var">T</span>) (<span class="id" type="var">H</span>:r1[=]<span class="id" type="var">r2</span>) (<span class="id" type="var">H0</span>:pse_int <span class="id" type="var">r1</span> <span class="id" type="var">e</span> <span class="id" type="var">t1</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#proj1_my_sigT">proj1_my_sigT</a></span> <span class="id" type="var">T</span> (<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">r2</span> <span class="id" type="var">e</span>) (<span class="id" type="lemma"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#replacement_lemma">replacement_lemma</a></span> <span class="id" type="var">H</span> <span class="id" type="var">H0</span>).<br/>

<br/>
<span class="id" type="keyword">Definition</span> <span class="id" type="definition"><a name="replace_in_term_proof">replace_in_term_proof</a></span> (<span class="id" type="var">T</span>:CSetoid) (<span class="id" type="var">r1</span> <span class="id" type="var">r2</span> <span class="id" type="var">t1</span>:T) <br/>
&nbsp;&nbsp;(<span class="id" type="var">e</span>:part_set_exp <span class="id" type="var">T</span>) (<span class="id" type="var">H</span>:r1[=]<span class="id" type="var">r2</span>) (<span class="id" type="var">H0</span>:pse_int <span class="id" type="var">r1</span> <span class="id" type="var">e</span> <span class="id" type="var">t1</span>) :=<br/>
&nbsp;&nbsp;<span class="id" type="definition"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#proj2_my_sigT">proj2_my_sigT</a></span> <span class="id" type="var">T</span> (<span class="id" type="inductive"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#pse_int">pse_int</a></span> <span class="id" type="var">r2</span> <span class="id" type="var">e</span>) (<span class="id" type="lemma"><a class="idref" href="CoRN.tactics.csetoid_rewrite.html#replacement_lemma">replacement_lemma</a></span> <span class="id" type="var">H</span> <span class="id" type="var">H0</span>).<br/>

<br/>

<br/>
</div>

<div class="doc">
The `quote function' maps from the semantical level to heavy syntactic 
expressions: given a setoid term <span class="inlinecode"><span class="id" type="var">t</span>:T</span>, <span class="inlinecode"><span class="id" type="var">psxe_quote</span></span> yields a 
<span class="inlinecode">(<span class="id" type="var">part_set_xexp</span> <span class="id" type="var">T</span>)</span>. Term <span class="inlinecode"><span class="id" type="var">r</span>:T</span> (supposed to be a subterm of <span class="inlinecode"><span class="id" type="var">t</span>:T</span> to be 
replaced later on) is mapped to <span class="inlinecode">(<span class="id" type="var">psxe_var</span> <span class="id" type="var">r</span>)</span>. Other `leafs' <span class="inlinecode"><span class="id" type="var">t0</span></span> of <span class="inlinecode"><span class="id" type="var">t</span></span> are 
mapped to <span class="inlinecode">(<span class="id" type="var">psxe_con</span> <span class="id" type="var">r</span> <span class="id" type="var">t0</span>)</span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Given <span class="inlinecode"><span class="id" type="var">H</span>:r1&equiv;<span class="id" type="var">r2</span></span> and <span class="inlinecode"><span class="id" type="var">A</span>:Prop</span> or <span class="inlinecode"><span class="id" type="var">A</span>:CProp</span>, <span class="inlinecode">(<span class="id" type="var">replace_in_formula2</span> <span class="id" type="var">H</span> <span class="id" type="var">A</span>)</span> 
replaces all occurrences of subterm <span class="inlinecode"><span class="id" type="var">r1</span></span> in <span class="inlinecode"><span class="id" type="var">A</span></span> by <span class="inlinecode"><span class="id" type="var">r2</span></span>. 
</div>
<div class="code">

<br/>

<br/>
</div>

<div class="doc">
Given <span class="inlinecode"><span class="id" type="var">T</span>:CSetoid;<span class="id" type="var">r1</span>,r2:T;<span class="id" type="var">H</span>:r1&equiv;<span class="id" type="var">r2</span>;<span class="id" type="var">H0</span>:r2&equiv;<span class="id" type="var">r1</span></span> (checked by main call) 
and <span class="inlinecode"><span class="id" type="var">A</span>:CProp</span> or <span class="inlinecode"><span class="id" type="var">A</span>:Prop</span>, we get <span class="inlinecode">(<span class="id" type="var">part_set_rewr_prf1</span> <span class="id" type="var">H</span> <span class="id" type="var">H0</span> <span class="id" type="var">A</span>) : <span class="id" type="var">A</span>-&gt;A[<span class="id" type="var">r2</span>/r1]</span> 
and <span class="inlinecode">(<span class="id" type="var">part_set_rewr_prf2</span> <span class="id" type="var">r1</span> <span class="id" type="var">r2</span> <span class="id" type="var">H</span> <span class="id" type="var">H0</span> <span class="id" type="var">A</span>) : <span class="id" type="var">A</span>[<span class="id" type="var">r2</span>/r1]-&gt;A</span> where <span class="inlinecode"><span class="id" type="var">A</span>[<span class="id" type="var">r2</span>/r1]</span> denotes 
<span class="inlinecode">(<span class="id" type="var">part_repl_in_form</span> <span class="id" type="var">H</span> <span class="id" type="var">A</span>)</span>. The argument <span class="inlinecode"><span class="id" type="var">H0</span>:r2&equiv;<span class="id" type="var">r1</span></span> is present to avoid 
iterated application of <span class="inlinecode"><span class="id" type="var">eq_symmetric</span></span>.

</div>
<div class="code">

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>

<br/>
</div>
</div>

<div id="footer">
<hr/><a href="index.html">Index</a><hr/>This page has been generated by <a href="http://coq.inria.fr">coqdoc</a>
</div>

</div>

</body>
</html>